<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cli | Hao Ruan's 部落格]]></title>
  <link href="http:///blog/categories/cli/atom.xml" rel="self"/>
  <link href="http:///"/>
  <updated>2017-07-30T22:41:47+08:00</updated>
  <id>http:///</id>
  <author>
    <name><![CDATA[Hao Ruan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Top]]></title>
    <link href="http:///blog/2016/11/30/top/"/>
    <updated>2016-11-30T13:41:06+08:00</updated>
    <id>http:///blog/2016/11/30/top</id>
    <content type="html"><![CDATA[<p><img src="/images/examples/top.png"></p>

<h3 id="section">性能指标</h3>

<ul>
  <li>us: 如果大于 50%，说明用户进程消耗的cpu时间多，需要考虑优化用户的程序</li>
  <li>us+sy: 大于 80% 说明可能存在 CPU 不足</li>
  <li>wa: 显示了 IO 等待所占用的 CPU 时间百分比。如果 wa 超过 30%，说明 IO 等待严重，可能是磁盘大量随机访问造成的，也可能磁盘或者磁盘访问控制器的带宽瓶颈造成的(主要是块操作)</li>
  <li>st(steal): 在如 Xen 等虚拟环境下 CPU 运行虚拟机时间的百分比。太高表示可能需要停止一些虚拟机</li>
</ul>

<h3 id="section-1">内存数量说明</h3>

<p>第四行中使用中的内存（used）指的是当前系统內核控制的内存数量，空闲内存（free）是内核尚未纳入其管控范围的數量。</p>

<p>纳入内核管理的内存不见得都在使用中，还包括可以被重复利用的内存，内核并不把这些可被重新使用的内存交换到 free 中去，因此在 linux 上 free 内存会越来越少，无需担心。</p>

<p>如果第五行 swap used 数值不为零且不断变化，说明内核不断进行内存 swap 操作，这是真正内存告急的征兆。</p>

<h3 id="buffers--cached">buffers &amp; cached</h3>

<p>buffers 和 cached 是内核管理的可用内存。从应用程序角度来看，buffers/cached 是等于可用的。</p>

<p>当应用程序需在用到内存的时候，buffers/cached 可以很快得被回收。</p>

<p>buffers/cached 可以用来提高文件读写性能，buffers 给块设备做缓冲区，cached 给文件做缓冲区。</p>

<h3 id="section-2">内存计算</h3>

<p>可用内存：free + ( buffers + cached )</p>

<p>已用内存：used - ( buffers + cached )</p>

<h3 id="shr">SHR</h3>

<p>SHR 是指加载外部动态库 (.so) 或者以共享内存方式进行进程间通信时所使用的共享内存区域。</p>

<p>这部分物理内存空间其实是被多个进程所共享的，所以称为共享内存。某个进程占用的内存除了和别的进程共享的内存之外就是自己的独占内存了。所以要计算进程独占内存的大小只要用 RES 的值减去 SHR 值即可。</p>

<h3 id="section-3">实用技巧</h3>

<ul>
  <li>P: CPU 排序</li>
  <li>M: 内存排序</li>
  <li>1: 显示 SMP 负载情况</li>
  <li>H: 显示线程信息</li>
  <li>z: 高亮模式</li>
  <li>c: 显示完整命令名</li>
  <li>k: kill 指定进程</li>
  <li>x: 指定排序栏高亮</li>
  <li>&lt; 和 &gt;: 指定排序栏</li>
  <li>top -p <pid>: 显示指定进程</pid></li>
  <li>top -bn 1: 显示一屏信息，用于脚本</li>
  <li>top -M 使用 megabytes 为单位</li>
  <li>top -H -p <pid>: 监控指定进程和进行内线程信息</pid></li>
</ul>

<h3 id="refs">Refs</h3>

<p><a href="http://www.cnblogs.com/bravery/archive/2012/06/27/2560611.html">观察进程的内存占用情况</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openssl]]></title>
    <link href="http:///blog/2016/09/22/openssl/"/>
    <updated>2016-09-22T10:22:15+08:00</updated>
    <id>http:///blog/2016/09/22/openssl</id>
    <content type="html"><![CDATA[<h2 id="section">制作自签署证书步骤</h2>

<p>自签署证书一般作为 CA 的证书，普通的证书一般由 CA 来签署，也可以按照该步骤制作自签署的普通证书（将自身作为 CA ）</p>

<ul>
  <li>&lt;1&gt; 生成密钥</li>
</ul>

<p><code>
openssl genrsa 2048 &gt;ca.key.pem ## 生成2048位私钥
openssl rsa -in ca.key.pem -pubout ## 查看公钥
</code></p>

<ul>
  <li>&lt;2&gt; 生成自签署证书</li>
</ul>

<p><code>
openssl req -new -x509 -key ca.key.pem -out ca.cert.pem -days 365 ## -x509 表示生成自签名证书
openssl x509 -text -in cacert.pem ## 查看证书内容
</code></p>

<h2 id="section-1">签署证书步骤</h2>

<ul>
  <li>&lt;1&gt; 生成 csr</li>
</ul>

<p><code>openssl req -new -key webserver.key -out webserver.csr</code></p>

<ul>
  <li>&lt;2&gt; 签署 csr</li>
</ul>

<p><code>openssl ca -in webserver.csr -out webserver.crt ## 需先部署好 openssl 的 CA 证书</code></p>

<h3 id="section-2">通过签署证书的方式设置证书的有效日期</h3>

<p><code>bash
rm -rf demoCA
mkdir -p demoCA/newcerts
touch demoCA/index.txt
openssl genrsa -out usc.key.pem 2048
openssl req -new -key usc.key.pem -out usc.csr.pem -subj "/C=US/ST=Califomia/L=Irvine/O=Cisco Systems, Inc./OU=Cisco Small Business/CN=Network Orchestrator Agent"
openssl ca -selfsign -keyfile usc.key.pem -startdate 20160901000000Z -days 7300 -batch -in usc.csr.pem -out usc.cert.pem -create_serial
rm -rf demoCA
</code></p>

<h2 id="openssl-">使用 openssl 加解密</h2>

<ul>
  <li>&lt;1&gt; 加密</li>
</ul>

<p><code>openssl enc -des3 -a -in ./test-cipher -out test-cipher.des3</code></p>

<ul>
  <li>&lt;2&gt; 解密</li>
</ul>

<p><code>openssl enc -des3 -d -a -in ./test-cipher.des3 -out test-cipher</code></p>

<h2 id="openssl--1">使用 openssl 生成随机字符串</h2>

<p><code>openssl rand -hex 10</code></p>

<h2 id="openssl--2">使用 openssl 查看握手信息</h2>

<p><code>openssl s_client -connect &lt;ip&gt;:&lt;port&gt;</code></p>

<h2 id="section-3">格式转换</h2>

<ul>
  <li>pksc1 =&gt; pksc8</li>
</ul>

<p><code>
openssl pkcs8 -topk8 -inform pem -in cakey.pem -outform pem -nocrypt -out cakey.pkcs8.pem
</code></p>

<ul>
  <li>pem =&gt; pksc12</li>
</ul>

<p><code>openssl pkcs12 -export -in ./client.crt -inkey ./client.key -out client.p12</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Socat]]></title>
    <link href="http:///blog/2016/09/20/socat/"/>
    <updated>2016-09-20T10:32:26+08:00</updated>
    <id>http:///blog/2016/09/20/socat</id>
    <content type="html"><![CDATA[<h2 id="socat-">使用 socat 打开端口传输文件</h2>

<ul>
  <li>&lt;1&gt; Server</li>
</ul>

<p><code>socat tcp-l:12345,reuseaddr,fork open:&lt;filename&gt;</code></p>

<ul>
  <li>&lt;2&gt; Client</li>
</ul>

<p><code>socat tcp:&lt;ip&gt;:12345 open:&lt;filename&gt;,create</code></p>

<h2 id="socat--1">使用 socat 打开端口登陆</h2>

<ul>
  <li>&lt;1&gt; Server</li>
</ul>

<p><code>socat tcp-listen:8888 exec:'bash -i',pty,setsid,stderr,echo=0</code></p>

<ul>
  <li>&lt;2&gt; Client</li>
</ul>

<p><code>socat readline &lt;server-ip&gt;:8888</code></p>

<h2 id="socat-tls-">使用 socat 建立tls 通信</h2>

<p><code>bash
socat -U openssl-listen:8443,reuseaddr,cert=server.crt.pem,key=server.key.pem,verify=0,fork open:&lt;filename&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ssh]]></title>
    <link href="http:///blog/2016/09/14/ssh/"/>
    <updated>2016-09-14T14:35:45+08:00</updated>
    <id>http:///blog/2016/09/14/ssh</id>
    <content type="html"><![CDATA[<h2 id="remote-forward">Remote Forward</h2>

<p><code>ssh -N -f -R &lt;remote-port&gt;:&lt;dest-host&gt;:&lt;dest-host-port&gt; user@remote-host</code></p>

<p><img src="/images/examples/ssh.png"></p>

<p>&lt;remote-port&gt; 监听在 localhost 上，如需要被外部访问，可以在 remote-host 上再添加一个端口转发:</p>

<p><code>socat TCP4-LISTEN:8888,reuseaddr,fork TCP4:127.0.0.1:&lt;remote-port&gt; &amp;</code></p>

<p>这样外部可以通过 &lt;remote-host&gt;:8888 访问 &lt;dest-host&gt;:&lt;dest-host-port&gt;</p>

<p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">Ref1</a></p>

<p><a href="http://www.liugj.com/2013/04/SSH-port-forwarding/">Ref2</a></p>

<h2 id="misc">Misc</h2>

<ul>
  <li>在远程机器上运行一段脚本（不必把脚本拷贝到远程机器上)</li>
</ul>

<p><code>ssh user@server bash &lt; /path/to/local/script.sh</code></p>

<ul>
  <li>比较一个远程文件个一个本地文件</li>
</ul>

<p><code>ssh user@host cat /path/to/remotefile | diff /path/to/localfile -</code></p>

<ul>
  <li>cat 文件</li>
</ul>

<p><code>ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub </code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dig]]></title>
    <link href="http:///blog/2016/06/24/dig/"/>
    <updated>2016-06-24T13:27:49+08:00</updated>
    <id>http:///blog/2016/06/24/dig</id>
    <content type="html"><![CDATA[<h2 id="section">查询域名过程</h2>

<p><code>bash
dig blog.ruan.host
</code></p>

<p><img src="/images/examples/dig.png"></p>

<ul>
  <li>HEADER</li>
</ul>

<p>查询参数和统计</p>

<ul>
  <li>QUESTION SECTION</li>
</ul>

<p>查询 <strong>blog.ruan.host</strong> 的 A 记录</p>

<ul>
  <li>ANSWER SECTION</li>
</ul>

<p>DNS 服务器的答复，508 是 TTL 值，表示 508 秒内不需要再查询</p>

<ul>
  <li>AUTHORITY SECTION</li>
</ul>

<p>显示 NAME SERVER (NS) 记录，即哪些服务器负责管理 <strong>fastlylb.net.</strong> 的 DNS 记录，
可以向任一台服务器查询 <strong>prod.github.map.fastlylb.net.</strong> 的 IP 地址</p>

<ul>
  <li>ADDITIONAL SECTION</li>
</ul>

<p>显示域名服务器的 IP 地址</p>

<h2 id="dns-">指定 DNS 服务器查询</h2>

<p>本机 DNS 服务器的 IP 地址保存在 <code>/etc/resolv.conf</code></p>

<p>也可以指定具体的服务器查询</p>

<p><code>bash
dig @8.8.8.8 blog.ruan.host
</code></p>

<h2 id="section-1">域名层级</h2>

<p><blockquote><p>HOST.SLD.TLD.root<br/>SLD :: second-level domain<br/>TLD :: top-level domain</p></blockquote></p>

<p><a href="http://www.iana.org/domains/root/db">顶级域名列表</a></p>

<h2 id="section-2">显示分级查询过程</h2>

<p><code>bash
dig +trace blog.ruan.host
</code></p>

<h2 id="ns-">单独查询每一级域名的 NS 记录</h2>

<p>``` bash
dig ns com.
dig ns host.
dig ns ruan.host.</p>

<p>dig +short ns com.
dig +short ns ruan.host.
```</p>

<h2 id="section-3">反向查询</h2>

<p><code>bash
dig -x 128.199.183.19
</code></p>

]]></content>
  </entry>
  
</feed>
